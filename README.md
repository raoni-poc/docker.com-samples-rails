You can now generate the Rails skeleton app using docker-compose run:

```bash
docker-compose run --no-deps web rails new . --force --database=postgresql
```

If you are running Docker on Linux, the files rails new created are 
owned by root. This happens because the container runs as the root user. 
If this is the case, change the ownership of the new files. If you are 
running Docker on Mac or Windows, you should already have ownership of 
all files, including those generated by rails new.

```bash
sudo chown -R $USER:$USER .
```

Now that you’ve got a new Gemfile, you need to build the image again. 
(This, and changes to the Gemfile or the Dockerfile, should be the only
times you’ll need to rebuild.)

```
docker-compose build
```

Connect the database The app is now bootable, but you’re not quite there yet. 
By default, Rails expects a database to be running on localhost - so you need
to point it at the db container instead. You also need to change the database 
and username to align with the defaults set by the postgres image.

Replace the contents of config/database.yml with the following:

```
default: &default
adapter: postgresql
encoding: unicode
host: db
username: postgres
password: password
pool: 5

development:
<<: *default
database: myapp_development


test:
<<: *default
database: myapp_test
```

You can now boot the app with docker-compose up. 
If all is well, you should see some PostgreSQL output

```
database system is ready to accept connections
```
Finally, you need to create the database. In another terminal, run:

```
docker-compose run web rake db:create
```


http://localhost:3000/

